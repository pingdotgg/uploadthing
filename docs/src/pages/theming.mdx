import { Callout } from "nextra-theme-docs";

# Theming

## Components anatomy

### UploadButton

Simplified component structure:

```jsx
<div data-state={getUtState()} className={className}>
  <label data-state={getUtState()} data-ut-element="button">
    <input />
    /button content goes here/
  </label>
  <div data-state={getUtState()} data-ut-element="allowed-content">
    /allowed content text goes here/
  </div>
</div>
```

<Callout type="info">
  UploadButton consists of three themable elements: container, button and
  allowed content.
</Callout>

<Callout type="warning">
  Note: UploadButton's button element is defined using `label`
</Callout>

import Image from "next/image";

<Image
  src="/upload-button-anatomy.png"
  alt="Upload button anatomy"
  width="1546"
  height="998"
  style={{ marginTop: "1rem", borderRadius: "0.5rem" }}
/>

### UploadDropzone

Simplified component structure:

```jsx
<div className={className} data-state={getUtState()}>
  <svg data-ut-element="upload-icon" data-state={getUtState()}>
    ...
  </svg>
  <label data-ut-element="label" data-state={getUtState()}>
    /label content goes here/
    <input disabled={!ready} />
  </label>
  <div data-ut-element="allowed-content" data-state={getUtState()}>
    /allowed content goes here/
  </div>
  <button
    data-ut-element="button"
    data-state={getUtState()}
    disabled={isUploading}
  >
    /button content goes here/
  </button>
</div>
```

<Callout type="info">
  UploadDropzone consists of five themable elements: container, upload icon,
  label, button and allowed content.
</Callout>

<Callout type="warning">
  Note: While in UploadButton the button element is defined using `label`, in
  UploadDropzone it is defined using `button`. As an abstraction layer, button
  element in these two components have special data attribute applied:
  `data-ut-element="button"`.
</Callout>

<Image
  src="/upload-dropzone-anatomy.png"
  alt="Upload dropzone anatomy"
  width="2010"
  height="1594"
  style={{ marginTop: "1rem", borderRadius: "0.5rem" }}
/>

## Theming props

### `className`

Both UploadButton and UploadDropzone accept `className` prop. It allows you to
pass any additional classes to the component. All classes that are being passed
through this prop are going to be applied to the outermost element - container

### `appearance`

Both `UploadButton` and `UploadDropzone` accept `appearance` prop. It accepts an
object with keys that correspond to elements of component. You can pass
following types of values:

- `string` - it will be applied as a class to the element
- `CSSProperties` object - it will be applied as an inline style to the element
- `callback` - it will be called with current state of the component and should
  return one of the above types

The interfaces of `appearance` prop for `UploadButton` and `UploadDropzone` are
following

```ts
type UploadButtonProps = {
  /* rest of props */
  appearance?: {
    container?: StyleField;
    button?: StyleField;
    allowedContent?: StyleField;
  };
};

type UploadDropzoneProps = {
  /* rest of props */
  appearance?: {
    container?: StyleField;
    uploadIcon?: StyleField;
    label?: StyleField;
    allowedContent?: StyleField;
    button?: StyleField;
  };
};
```

The types of callback arguments are following:

```ts
type ButtonCallbackArguments = {
  ready: boolean;
  isUploading: boolean;
  uploadProgress: number;
  fileTypes: string[];
};

type DropzoneCallbackArguments = {
  ready: boolean;
  isUploading: boolean;
  uploadProgress: number;
  fileTypes: string[];
  isDragActive: boolean;
};
```

## How to theme

### With TailwindCSS

#### Configuring TailwindCSS

To leverage best developer experience, we strongly recommend extending your
TailwindCSS config using our utility function `withUt`

<Callout type="warning">
  Note: `withUt` is optional but if you do not use it, you will not be able to
  use new classes and variants it adds. Also, in case you are not using it, make
  sure to import default stylesheet into your app.
</Callout>

```ts filename="tailwind.config.ts"
import { withUt } from "@uploadthing/react/tw";

/** @type {import('tailwindcss').Config} */
export default withUt({
  // your config goes here
});
```

```js filename="tailwind.config.js"
// @ts-check
const { withUt } = require("@uploadthing/react/tw");

/** @type {import('tailwindcss').Config} */
module.exports = withUt({
  // your config goes here
});
```

`withUt` does two major things:

- Adds new entry to `content` property so that it includes UploadThing's
  components. It allows to avoid having duplicated styles in your bundle.
- Registers plugin and adds nice-to-have classes to improve styling experience.

#### `className` prop

`className` prop accepts any classes so you can pass there anything you like.
When it comes to TailwindCSS, to make styling easier, `withUt` adds few utility
classes and variants for you to leverage.

Tailwind variants that allow applying styles to internal elements and their
arbitrary variant alternatives:

| Custom variant       |                        Arbitrary variant |
| :------------------- | ---------------------------------------: |
| `ut-button`          |          `&>*[data-ut-element="button"]` |
| `ut-allowed-content` | `&>*[data-ut-element="allowed-content"]` |
| `ut-label`           |           `&>*[data-ut-element="label"]` |
| `ut-upload-icon`     |     `&>*[data-ut-element="upload-icon"]` |

Tailwind classes that allow applying styles based on state of element and their
arbitrary `data` class alternatives:

| Custom class   |          Arbitrary class |
| :------------- | -----------------------: |
| `ut-readying`  |  `data-[state=readying]` |
| `ut-ready`     |     `data-[state=ready]` |
| `ut-uploading` | `data-[state=uploading]` |

These variants and classes can be used in conjunction with each other to make
component match your design in the exact way you want.

```jsx
<UploadButton
    className="bg-blue-500 ut-button:bg-cyan-500 ut-button:ut-readying:bg-cyan-500/50"
               ^           ^ applied to button   ^ applied to button when loading config
               | applied to container

/>

<UploadDropzone
    className="bg-blue-500 ut-label:text-lg ut-allowed-content:ut-uploading:text-red-300"
               ^           ^                ^ applied to allowed content when uploading file
               |           | applied to label
               | applied to container

/>
```

#### `appearance` prop

If you need, you can pass TailwindCSS classes directly to specific elements of
component or provide a callback that will be called with current state of the
component and will return a string

```jsx
<UploadButton
  appearance={{
    button({ ready, isUploading }) {
      return `${ready ? "bg-green-500" : "bg-red-500"} ${
        isUploading ? "cursor-not-allowed" : ""
      } after:bg-orange-400`;
    },
    container: "p-4 border rounded border-2 border-cyan-300",
    allowedContent: "h-8 flex flex-col items-center justify-center bg-red-100",
  }}
/>
```

### With custom classes

#### `className` prop

`className` prop accepts any classes so you can pass there anything you like.
When it comes to custom classes, you can use `data` attributes to target
specific elements of component.

```jsx
<UploadButton className="custom-class" />
```

```css
/* applied to container */
.custom-class {
  background-color: blue;
}

/* applied to container when readying */
.custom-class[data-ut-state="readying"] {
  background-color: cyan;
}

/* applied to button */
.custom-class > *[data-ut-element="button"] {
  font-size: 2rem;
  color: black;
}

/* applied to button when uploading */
.custom-class > *[data-ut-element="button"][data-ut-state="uploading"] {
  color: red;
}
```

#### `appearance` prop

If you need, you can pass classes directly to specific elements of component or
provide a callback that will be called with current state of the component and
will return a string

```jsx
<UploadButton
  appearance={{
    button({ ready, isUploading }) {
      return `custom-button ${
        ready ? "custom-button-ready" : "custom-button-not-ready"
      } ${isUploading ? "custom-button-uploading" : ""}`;
    },
    container: "custom-container",
    allowedContent: "custom-allowed-content",
  }}
/>
```

```css
/* applied to container */
.custom-container {
  background-color: blue;
}

/* applied to container when readying */
.custom-container[data-ut-state="readying"] {
  background-color: cyan;
}

/* applied to button */
.custom-button {
  font-size: 2rem;
  color: black;
}

/* applied to button when uploading */
.custom-button-uploading {
  color: red;
}

/* applied to button when ready */
.custom-button-ready {
  color: green;
}

/* applied to button when not ready */
.custom-button-not-ready {
  color: red;
}
```

### With inline styles

#### `appearance` prop

If you need, you can pass inline styles directly to specific elements of
component or provide a callback that will be called with current state of the
component and will return a `CSSProperties` object

```jsx
<UploadButton
  appearance={{
    button({ ready, isUploading }) {
      return {
        fontSize: "2rem",
        color: "black",
        ...(ready && { color: "green" }),
        ...(isUploading && { color: "red" }),
      };
    },
    container: {
      backgroundColor: "blue",
    },
    allowedContent: {
      backgroundColor: "red",
    },
  }}
/>
```

## Content customisation

To customise content of `UploadButton` and `UploadDropzone`, you can use
`content` prop.

The interfaces of `content` prop for `UploadButton` and `UploadDropzone` are
following:

```ts
type UploadButtonProps = {
  /* rest of props */
  content?: {
    button?: ContentField;
    allowedContent?: ContentField;
  };
};

type UploadDropzoneProps = {
  /* rest of props */
  content?: {
    uploadIcon?: ContentField;
    label?: ContentField;
    allowedContent?: ContentField;
    button?: ContentField;
  };
};
```

`content` prop allows you to customise the text and specific elements of
`UploadButton` and `UploadDropzone`. It accepts an object with keys that
correspond to content elements of component. You can pass following types of
values:

- `ReactNode`
- `callback` - it will be called with current state of the component and should
  return `ReactNode`

```jsx
<UploadButton
  content={{
    button({ ready }) {
      if (ready) return <div>Upload stuff</div>;

      return "Getting ready...";
    },
    allowedContent({ ready, fileTypes, isUploading }) {
      if (!ready) return "Checking what you allow";
      if (isUploading) return "Seems stuff is uploading";
      return `Stuff you can upload: ${fileTypes.join(", ")}`;
    },
  }}
/>
```
